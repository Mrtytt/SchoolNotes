%%SORU%%
#### Resource-allocation-graph algorthm
* nerde kilitlenme olup olmayacağını tahmin edebilir
* resource allocation kullanılması için her kaynaktan **1 tane** olduğunda kullanılabilir 

* kaynaktan processe assignment gösterir - assignment edge
* processten kaynağa giden request - request edge 
* çizikli çizgiler tahminlerdir , ihtiyaç duyabilirt - claim edge
* bir çevrim oluşmamalı bu deadlock anlamına gelir buna göre hareketlerini değerlendirir

##### wait-for 
* resource allocation graphından kaynaklar çıkarılırsa wait-for graphı elde edilir
* waitfor da döngü varsa deadlock vardır

%%SORU%%
#### banker algoritması
* para çeken arkada para yatıran önde -> safe state , deadlock olmaz
* sekansın tümü sorunsuz şekilde kullanabilirse -> safe state 
* para yatıran arkada para çeken önde -> unsafe state

* bir process sisteme geldiğinde maksimum kaynak ihtiyacını bildirir

* Available -> vektör şeklinde ifade edilir, o anda boş kaynakları gösterir
* Max -> processlerin kaynaklara olan max isteklerini gösterir
* Allocation -> tahsis edilen kaynakları gösteriyor
* Need = max - allocation;

### deadlock algılama
* deadlock problemlerini çözmek için
    * resource allocation graph -> kaynaklar 1 er tane
    * banker algoritması -> kaynaklar 1 den çok ise
    - request matrisi maksimum ve need matrislerinin karşılığıdır, need e benzer

### deadlocktan kurtulma
* manuel giderilebilir -> resetlemek
* sistem otomatik olarak recover yapabilir
    * kilitlenmeye sebep olan processler sonlandırılabilir

* 2 yöntem kullandırılır
    * deadlock durumunda kullanılan tüm processler sonlandırılır
    * deadlock döngüsü yok olana kadar processler sonlandırılır

* bir processin abort edilemesi durumunda tutarsızlıklar oluşabilir
    * dosya yazma işlemi yarıda kalabilir
    * yazıcıda devam eden yazdırma yarıda kalabilir

### resource preemption
* kaynakların boşa çıkarılması
* deadlock çözülenekadar atanmış kaynaklar alınarak başka processlere atanır
    * **selecting a victim** maliet hesaplanır, deadlock olma sıklığı, çalışma süresi
    * **rollback** processlerin çalışması garanti edilemiyorsa process iptal edilip tekrar başlatılabilir
    * **starvation** bir process sürekli kesilirse, victim olarak seçilmesinde maksimum limit belirlenebilir


## Main Memory 'RAM'
* main memory, general purpose registerlar -> geçici genel amaçlı kayıt alanlarıdır
* makine komutlarında hafıza adresini parametre olarak alan komutlar vardır ama disk adresini alan komutlar yoktur
* cpunun ihtiyaç duyduğu veri veya komut hafızada olmalıdır

* cpu registerlara 1 cycle da erişebilir
* hafızaya erişim buslar üzerinden yapılır

* bir processe ayrılan alana başka processler, başka kullanıcılar (çok kullanıcılı sistem) erişemez
* koruma işlemleri donanım düzeyinde yapılır, işletim sisteminde yapılırsa performans düşer

* **base** bellekteki taban adresi
* **limit** bellekteki tavan adresi

* cpunun ürettiği mantıksal adres -> base ve limit değerleriyle karşıkaştırılır

#### Adress binding
* bir process belleğe alınmak için input queue ya alınır

* kaynak progranda adres genellikle semboliktir
* derleyici bu adresleri yeniden yerleştirir 'relocateable'  
* **linkage editor**, **loader** bu sembolik adresleri mutlak 'absolute' adreslere dönüştürür

* komutların veya verilerin bağlanması
    * compile time -> derlenirken yapılabilir, mutlak code oluşturulabilir, yer değişirse tekrar compilelanmalı (statik)
    * load time -> yüklenirken (statik)
    * excetuion time -> bir segmentten başka segmente geçilebilir, adress binding runtime da yapılır (dinamik)

#### Mantıksal ve fiziksel adres alanı
* cpu mantıksal adress üretir

%%SORU%%
* compile time yada load time da mantıksal veya fiziksel adress üretilir
* excetion time da adress bağlama virtual adress olarak geçer (page number + offset)

* runtimeda sanal adresin fiziksel adrese dönüştürülmesi donanım bileşeni MMU tarafından yapılır

* base register , relocation register -> base adress tutulur
* mantıksal adresse + base adress = fiziksel adress işlemi yapılır
* mantıksal adress [0, max] fiziksel adress [R, R+max] aralığındadır

#### Dynamic Loading
* programın tamamı hafızaya yüklenmez, gerektikçe blok halinde yüklenir
* önce main program hafızaya yüklenir ve çalıştırılır
* bir program parçası(routine) çalışırken başka routini çapırdığunda loader tarfından hafızaya yüklenir
* kapladığı alan itibariyle büyük olan processlerin hafızaya yüklenip çalışmasını sağlar
* sık kullanılmayan rutinlerin hafızada sürekli bulunmasını engeller
