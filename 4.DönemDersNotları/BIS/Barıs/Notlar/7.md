### İşlemler arası iletişim için kullanılan ilk mekanizmalar
- İşlemler arası sinyal gönderilebilmesi için gerekli yetkiye sahip olması lazım. Yani her process'in sinyal gönderme yetkisi yoktur.
- Unix'te root'un full sinyal gönderme yetkisi vardır.
- Mesela bir hata gerçekleştiğinde işlemciye hata sinyali gönderilir.
* Bir işlemin başka bir işleme sinyal gönderebilmesi için her iki işlemin de aynı process grubu içinde veya aynı kullanıcı içinde olması lazım. #Önemli
- Bir sinyalin bir işlem tarafından alıgalanabilmesi ve işleenbilmesi için sinyalin blokelenmemiş olması (try-catch) ve çalışması kesilebilir (interruptable) surumda olması lazım.
- Bir sinyalin oluşması için çalıştırılan fonksiyona signal handler denilir.

### İşlemler arası iletişim nesnelerinin kalıcılığı
1. İşlem seviyesinde kalıcılık:
	* Process çalıştığı sürece obje hayatını devam ettirir.
	* İhtiyaç kalmazsa önceden de sonlandırılabilir. #Önemli
	* **pipe** türü nesneler örnek olarak verilir.

2. İşletim seviye kalıcılık:
	* İşletim sistemi çalıştığı sürece devam eder. 
	* Yani process sonlansa bile yine çalışmaya devam eder yani çalışmaya hazır halde bekler. #Önemli 
	* **Mesaj kuyrukları, semaforlar ve paylaşımlı bellekler** örnek verilebilir

3. Dosya seviyesinde kalıcılık:
	* Varlıklarını devamlı olarak sürdürürler. 
	- İşletim sistemi kapatılsa bile varlıklarını sürdürürler
	* Dosya silinirse bir tek varlıklarını devam ettiremez. #Önemli 
	* POSIX mesaj kutuları, paylaşılan belgeler, ...

	- Not POSIX ile mesaj kuyruğu, paylaşılan bellek, semaforlar, pipeler barındırılır

### Multi-threading modelleri

* Çalışabilmesi için kernel moda geçilip kernel thread ile user thread arasında ilişkilendirme modellerinden birini kullanmalı #Önemli :

	- Many to One:
		- Eğer bir thread sistem çağrısı bloklarsa tüm process bloklanır.
		- Aynı anda sadece bir tane kullanıcı thread'i kernel thread'ine erişir

	- One to One:
		- Biri bloklanırsa öbürleri çalışmaya devam eder.
		- Multicore sistemlerde eşzamanlı çalışmasına izin verilir.
		- Kötü yanı çok sayıda kernel thread oluşur ve karmaşıklık artar.

	- Many to Many:
		- User thread kernel thread'den daha fazla olur genelde.
		- One to One'nın sorunları çözülür.
		- Bir thread bir sistem çağrısını bloklarsa kernel başka bir threadi çalıştırır.

	- İki seviyeli model:
		- Hem çoktan çoğa hem de birden bire modeli eşleştirir , birlikte çalışırlar
		- Solaris OS 9. sürüm

#### Thread kütüphaneleri
- Programcıya thread oluşturmak ve yönetmek için API sağlar.

- Kütüphaneyi oluştururken 2 yaklaşım vardır:
	1. Tüm kütüphane kullanıcı alanda oluşturulur ve kernel desteği yoktur.
	2. İşletim sisteminin doğrudan desteklediği kernel seviyesinde kütüphane oluşturulur.

- İki strateji vardır:
	1. Asenkron threading:
		- Threadler arasında veri paylaşımı az olduğunda kullanılır.
		- Yeni child oluşturulduğunda çalışmalarını eşzamanlı olarak devam ettirebilirler
	1. Senkron threading:
		- Parent child başladığında processini durdurur bunlar tamamlandığında çalışmasına devam eder.
		- Threadler arasında veri paylaşımı fazla olduğunda kullanılır

* Günümüzde 3 temel kütüphane vardır #Önemli:
	1. POSIX Pthreads
	2. Windows threads
	3. Java threads :
		* Java thread’leri arasında veri paylaşımı parameter passing ile yapılır.

		- Java ile iki farklı teknik kullanılarak thread oluşturulabilir:
			- Thread sınıfından yeni bir sınıf türetilir ve run() metodu override yapılır.
			- Runnable arayüzünü kullanan bir sınıf oluşturulur.(yaygın kullanılır.)


#Not Bunların tam olarak nasıl çalıştığı slaytlarda var ve orası da önemlidir.

#### Dolaylı thread oluşturma

- Çok sayıda thread ile uygulama yapmak zordur.
- Thread oluşturma işi geliştirici yerine compiler tarafından yapılması günümüzde giderek popüler hale gelmektedir.
- Bu stratejiye implict (üstü kapalı) threading olarak tanımlanır.

- Thread pool:
	- Multithread bir web sunucusu, gelen isteklerin her birisi için yeni thread oluşturur.
	- Çok sayıda istek aynı anda gelirse sistem kaynakları çok çabuk dolar.
	- Bunun önüne geçmek için sistem önceden hazırda tuttuğu threadler vardır bu şekilde yeni thread oluşturmak için kaybedilecek zamanın önüne geçilir , Sistem belli sayıda thread hazırda tutmasıdır kısacası.

- OpenMP:
	- C, C++ ve fortran için yazılmış bir grup compiler direktiftir.
	- Shared memory ykalaşımı kullanır.
	* OpenMP ile **#pragma omp paralel** direktifi paralel çalışacak bloğun başında kullanılır #Önemli 

- Grand Central dispatch:
	- Apple sistemleri için OpenMP diyebiliriz.
	* Dispatch queue serial veya concurrent (Eşzamanlı çalışma) şeklinde oluşturulabilir #Önemli 

	- **Serial queue**		FIFO çalışır ve sadece bir blok kuyruktan alınır.
	- **Concurrnet queue** 	FIFO çalışır ve kuyruktan birden fazla blok aynı anda alınabilir.

	* **Concurrnet queue** da 3 farklı dispatch kuyruğu vardır: #Önemli 
		- Low (Önemli değil)
		- Default (Orta düzey önemde)
		- High (Mümkün olduğunca hızlı corede koşulması lazım)

#### Thread çalıştıma kuralları

- Signal handling:
	- Unix sistemlerde bir sinyal belirli bir olayın gerçekleştiğini gösterir.

	- Threadler yaptıkları işlemler için iletişim kurmak ister.

	- Oluşan olaya karşılık sinyal bir processe iletilir.
	- Sinyal senkron veya asenkron alınabilir.

	* **Senkron sinyal**	sinyalin oluşmasına neden olan olayı gerçekleştiren processe iletilir.
		- İllegal hafıza erişimi veya 0'a bölme #örnek 

	* **Asenkron sinyal** 	sinyali oluşturan processten başka bir processe iletilir.

	* Sinyaller process içindeki farklı hedeflere gönderebilir:
		- Bir threade
		- Tüm threadlere
		- Bazı threadlere

- Thread iptal etme: #örnek 
	- İşlem tamamlanmadan iptal edilebilir. 
	- İstenen bir sonucun bir threadin tarafından bulunması sonucu iptal edilebilir. 
	- Bir web sayfasaına girerken stop tuşuna basılırsaprocess içindeki tüm threadler iptal edilir. 
	- Bir thread çalışırken başka bir thread aniden onu sonlandırabilir. #Önemli 
	- Bir thread başka bir threadin kendi kendisini doğal biçimde iptal etmesini sağlayabilir.

#### Windows ve linux threadleri

##### Windows threadleri:

- Temel api olarak Windows API kullanır.
- thread için şu thread komutları kullanır:
	* ETHREAD: Thread çalıştırılır
	* KTHREAD: Kernel ile ilgili kısımlar
	* TEB: Thread Enviroment Block, User kısımdadır ve uygulama çevresi olarak tanımlanabilir

##### Linux threadleri:
* clone() veya fork() ile sistem çağrısı ile thread oluşturabilir #Önemli 
- fork() ile yeni görev başlattığında parent task veri yapısı kopyalanır. clone() ile ise istediğin gibi kısıtlamalar yapılabilir.

#### Process senkronizasyonu
* Cooperative processler diğer processleri etkileyebilir veya diğer processlerden etkilenebilir.
- Bunlar paylaşılmış hafıza veya dosya sistemleri ile veri paylaşımı yaparlar.

* Paylaşımlı veriye eşzamanlı erişim tutarsızlık problemlerine yol açabilir. Aynı anda değişiklik yapılırsa bu gerçekleşir yani iletişim yoksa bu olur. #Önemli 

- Bu yöntem yavaştır çünkü ilk virtual memorye bakar sonrasında kalan hafızaya bakmak zorundadır.
- Gelişigüzel veriye erişilmemdli, yani planlama yapılmalı.

- Paylaşılan veriye erişim üretici - tüketici ilişkisi olarak gösterilebilir. Öncelikle üretilmeliki tüketilsin.
- Bir işleme ait iş parçacıklarına micro işlem denir.

#### Eşzamanlılık (Concurrency): #Önemli 

- Eş zamanlı process olması durumunda bu 4 madde önem kazanır:
	- Processler arası haberleşme
	- Kaynak paylaşımı
	- Birden fazla processin senkronizasyonu
	- İşlemci zaman atanması

- Sorunlar:
	- Bir processin çalışma hızı öngörülemez:
		- Diğer processlerin yaptıklarına bağlıdır.
		- İşletim sisteminin kesmeleri nasıl ele aldığına bağlıdır mesela bazılarına görmezden gel ya da beklet falan diyebilir.
		- İş sıralama yaklaşımına bağlıdır.

- Çözüm:
	- Paylaşılan kaynaklara kontrollü erişim.
	- Senkronizasyon
	
- Processlerin etkileşimi:
	- Birbirinden habersizlerse: Rekabet
	- Birbiriden dolaylı olarak haberleri vardır: Paylaşma yoluyla işbirliği
	- Processlerin direkt birbirinden haberi vardır: Haberleşme yoluyla işbirliği
