# Multi-processor sccheduling
* Asymetric multiprocessing -> 1 cpu master olarak atanır bu cpu diğerlerine atanacak işlemlere karar verir
* Symetric multiprocessing -> hepsi eş değerde
- tüm cpular aynı hazır kuyruğuna sahip olabilir
- windows, linux, macos SymetricMultiProcessing destekler

* bir process başka bir işlemciye aktarıldığında cache bilgileri taşınmaz

* Hit oranı -> ramdeki verinin cache lerde bulunmasıyla rame gitme gereksinimi kalmaması

* bir process başka bir işlemciye taşınırsa cache hit oranı düşer

* processor affinity -> bir process çalışmakta olduğu işlemciyle ilişkilendirilebilir 
    * hard affinity -> aynı cpu ve core arasında çalışması garantisi
    * soft affinity -> aynı cpu ve core arasında çalışması garantisi bulunmaz
    - hard softa göre daha hızlı çalışabilir
    - linux soft ve hard affinity kullanır

### Yük dengeleme 'load balancing'
* SMP sistemlerde tüm işlemciler üzerinde iş yükü dağıtarak verimi arttırmayı amaçlar

* her işlemcinin kendi kuyruğu varsa yük dengleme iyi yapılmazsa bazı işlemciler boş beklerken bazıları yoğun çalışır

* ortak kuyruk sistemlerde pek yük dengelemeye gerek olmaz

* **Push Migration** fazla yükü diğer işlemcilere itiyor
* **Pull Migration** fazla yükü kendi üzerine çeker

* bir core a bir den fazla thread atanabilir: compute cycle ve memory cycle ların arasında geçiş yapılır
- thread0 -> C | M | C | M | C |M | C | M | C 
- thread1 ->     C | M | C | M | C |M | C | M | C

### Gerçek zamanlı CPU planlama

* **soft real time sistemler** zaman kritik processlere diğerlerine göre öncelik verir ancak çalışma süresine garanti vermez
* **hard real time sistemler** zaman kritik processleri deadline süresinde çalıştırma garanti

### Minimizing latency 
* **event latency** bir olay oluştuktan sonra işlemin gerçekleşmesine kadar, tepki vermesine kadar geçen süre

* real time systemlerin performansını interrupt ve dispatch latency etkiler 

* **interrupt latency** : interrupt ve determine interrupt type süresi
*  task t -> interrupt -> determine interrupt type -> context switch -> ISR (interrupt service routine)

* bir processin kapatılarak diğer bir processin başlatlması için geçen süreye dispatch latency denir

* dispatch latency = conflicts + dispatch

### Gerçek zamanlı CPU planlama

#### priority based scheduling
* gerçek tabanlı sistemler öncelik tabanlı algoritma kullanmak zorundadır
* windows 32 seviyeli önceleklendirme yapar 16-31 arası gerçek amanlı processlere ayrılmıştır
* öncelik değeri verilmemişse : daha sıklıkla gerçekleşen olaylara daha çok önem verilir, periotlarına bakınır kısa olan seçilir
* bir process için deadline dan önce çalışma garantisi yoktur
* soft real-time garanti edilir
* **deadline** birsonraki periyodun başlangıcıdır

##### Rate-Monotonic Scheduling
* her process periyot süresi ile ters orantalı şekilde önceliklendirilir
* periyot süresi kısaldıkça öncelik seviyesi artar
* periyot süresi aynı ise burst time a bakılabilir
%%SORU%%
##### Earliest-Deadline-First Scheduling
* rate monotonice göre deadline sağlayan process oranı artar
* deadlineı kısa olanın öncelik seviyesi yüksektir
### Sistem Modeli
* kaynaklar : cpu cycle, dosyalar , io cihazları
* bir process bir kaynağı kullanmadan önce istek yapar , kullandıktan sonra serbest bırakır
* bir procesin kaynağı kullanma sırası
    - request   talep eder, dönülmezse bekler
    - use       üzerinde işlem yapar
    - release   serbest bırakır
%%SORU?%%
* cihaz için request, release; dosya için open,close; hafıza için allocate, free syscall lar kullanılır

%%SORU?%%
* işletim sistemleri kaynakların boş veya atanmış olduğunu bir tablo ile tutar
