## Virtual Memory
* proccessin rame gelmesi lazım fakat ramde yer yoksa 
* sanal bellek programcı için hafıza limitini kaldırır

* negatifi yavaş olması ve gecikmedir

* sanal bellek alanının kullanılacağı zaman bir fiziksel bllek alanıyla ilişkilendirilmesi gerekir

* processlere ait page tabloları muhakkak fiziksel bellekte tutulur

- processin stack ve heap alanı dinamik büyüyebilir

#### Demand paging
* processin ihtiyacı olduğu sayfaların talep edilmesidir
* kullanılmayan sayfalar belleğe yüklenmez
* swaping kullanılarak belleğe gelmesini sağlar
* gerekmedikçe belleğe yüklemiyorsa **lazy swapper** denilir

* **pager** bir process swap in yapıldığında swap out yapılana kadar hangi sayfaların kullanılacağını tahmin eder

* bir sayfanın hafızadamı disktemi oldunu tutmak için valid, invalid belirtme bitleri kullanılır 
* invalid bir sayfaya erişmeye çalışılırsa page fault oluşur, işlteim sistemi pagi hafızaya aktarır

* bir process daha ilk kez çalıştırıldığında tüm pageleri belleğe yerleştirilmediği için en az 1 kez page fault üretirler
* **poor demand paging**
* bir progrmacı tek bir instruction ile birden çok sayfaya erişebilir birden çok page fault oluşur

* fork() syscallı ile oluşan bir child process parent processin pagelerini okuyabilir ama ne zaman bu pagelerde bir değişiklik yapmak isterse bu pagin bir kopyası oluşturulur böylece orijinal page korunmuş olur

### Page Replacement

* bellek dolu ise ve bir page çağrılırsa , bir page swap out yapıp yerine yenisi konulur

#### temel algoritma
* boş frame yoksa o anda kullanılmayan bir frame seçilir ve swap out yapılır
* swap out yapılan page için page table invaild yapılır 

* swap in yaparkende page table güncellenir

* **modify biti** pagin güncellenp güncellenmediği kontrol etmesi için kullanılır

* tahsis edilen frame sayısı artıkça oluşan page fault sayısı azalır

%%SORU ilk 3 ü%%
#### FIFO page Replacement
* belleğe gelen ilk sayfa çıkartılır
* bazen fifo algoritmasında frame sayısı arttığında daha fazla page fault oluşabilir

* her zaman en kötü sonuç üretir

#### Optimal Page Replacement
* en uzun süre kullanılmayacak sayfa ile yer değtirilir
* bir gelecek projeksiyonu tutuar buna göre karar veir

* ileriye bakılır
* hem lru hem fifoya göre daha iyidir genelde

#### least recently used page Replacement
* en uzun süre kullanılmayan seçilir
* bir sayaca ihtiyaç duyulur

* geriye bakılır

#### Counting-based page replacement
* her kullanıldıkça değeri artar

### Frame Allocation
* bellekte os için ayrılan alan dışında tüm frameler kullanılabilir
* bir procese çalışması için gereken minimum frame sayısı atanır

* bir komut kümesinde her komut sadece bir hafıza erişimi yapıyorsa 
    - bir frame instruction
    - bir frame data içerir

* indirect adresleme varsa
    - 3 olarak bir frame daha tutulur

%%SORU%%
####

p_1 -> 10
p_2 -> 127

m = 62
S = 10 + 127 = 137

p_1 -> (10 / 137) * 62 = 5
p_2 -> (127 / 137) * 62 = 57

#### Global - Local Replacement 
* **global atama** algoritmaları ilk boş yere atama yapar
    * düşük öncelikli processler yerine yüksek öncelikli procesler atanabilir
    * processler kendi page fault oranlarını kontrol edemezler

* **local replacement** algoritmaları bir prcese atanmış frameler arasında çalışır
    * processlerin frame sayısı değişmez

#### Thrashing
* bir process için gerekli minimum frame sayısnın altına düşerse process beklemeye alınır
* processin tüm frameleri boşaltılır
* processe yeterli sayıda frame verilmezse sık sık page fault oluşur
* yüksek orandaki sayfalama işlemine thrashing 'boşuna çalışma' denir
* thrashing pagingi geçmemlidir

* page fault arttıkça porcessler paging biriminde sıra beklemeya bşalr ve cpu hazır kuyruğu boşalır

* multi programming derecesi arttıkça bir yere kadar cpu kullanımı artar ama belirli bir noktadan sonra azalır bu noktanın ilerisinde thrashing olur

* local replacement kullanılarak thrashing azaltılabilir

* bir procesin herhangi bir anda ihtiyaç duyacağı sayflaar locality model ile belirlenir

* bir process localiyden localitye geçiş yaparak çalışır"