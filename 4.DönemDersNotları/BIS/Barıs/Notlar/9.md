###

// deadlock, starvation, race sistemin performansını etkiler kurtulunmalıdır


### Processlerin Etkileşimi
    # Rekabet
        processlerin birbirinden haberiz olduğu durum
    # Paylaşma yoluyla işbirliği
        processlerin dolaylı olarak birbirinden haberleri vardır
        dosya ortak iş ortak olabilir
    # Haberleşme yoluyla işbirliği
        processlerin doğrudan birbirlerinden haberi vardır

#### Rekabet
    Birbirinden habersiz processlerin aynı kaynağı (ram, cpu time) kullanma istekleri

    bir processin sonuçları diğerinden bağımsız ise

    her ne kadar bağımsız processler olsada kaynaklar ortak olduğu için
    **processin çalışma süresi etkilenir**

    # Karşılıklı dışlama 'mutual exclusion'
        bir processin kritik sectionu çalışıyorken başka bir processin kritik sectionu çalışmaz , collision oluşabilir
    # Ölümcül kilitlenme 'deadlock'
    # Yarış 'race'
        kaynağa ilk gelen ilk alır
        senkronizasyon yoksa yarış durumu oluşur
    # Açlık 'starvation'
        çok uzun bir süre başka bir processin ihtiyacı olan kaynağı bırakmazsak ona ihtiyacı olan process açlık çeker

#### Paylaşım Yoluyla İşbirliği
    paylaşılan -> dosya, veri tabanı
    üretilen çıktı -> girdi çıktı

    karşılıklı dışlama gerekli
        okuma yapılırken mutual exclusion gerekli değildir

    senkronizasyon gerekebilir

    # Sorunlar
        deadlock , yarış , açlık

#### Haberleşme Yoluyla İşbirliği
    Mesaj aktarımı yoluyla haberleşme

    karşılıklı dışlama gerekli değil

    deadlock
        birbirinden mesaj bekleyen 2 process

    starvation
        2 process mesajlaşabilir, 3. process 2sinden birininden mesaj bekler
    
    // Critical Section
        Program kodunun main methodu, paylaşılan kaynaklar üzerinde işlem yapan kısmı
    // Mutual Exclusion
        Belirli bir anda sadece 1 processin Critical Sectionu nun çalışması
    // Deadlock
        Birinin istediği kaynağı birdiğeri tutup bırakmaz ise, processler ilerleme kaydedemez
        yeniden başlatmak -> tüm processlerden kaynakları almak
        task manager -> bir processin kaynaklarını elinden almak
    // Race
        Aynı ortak verilere erişen processler
        Sonuç processlerin çalışma hızına be sıralarına bağlıdır
        Farklı çalışmalarda farklı sonuçlar üretilebilir
    // Starvation
        aynı kaynakları kullanan processler
        bazı processlerin bekledikleri kaynaklara erişememe durumu -> sonsuz bekleme olabilir

### Processlerin Senkroniziasyonu
    paylaşılan bir değişkene aynı anda sadece bir processin erişimini sağlamaak zorundadır 'process synconization'

    aynı veriye erişim , multi-core işlemcilerde zorunludur

    entry section -> critical section a giriş izni ister
    critical section -> ortak kısımlar üzerinde işlem yapan kod bloğu
                     -> global değişkenler yer alabilir
    exit section -> bulunabilir

#### Kritik Bölüm Problemi

    %%SORU%%
    1 - **Mutual Exclusion** birinin kritik bölümü çalışyorsa diğerlerine izin verilmemeli
    2 - **Progress** hiç biri kritik bölümü çalıştırmıyorsa herhangi birine izin verilir
    3 - **Bounded Waiting 'Sınırlı Bekleme'** bir process izin istemesinden ve izin alınana kadar istenilen süre kısıtlanmalıdır

    Hafıza tahsisi ve interrupt gibi yapılar 'race' durumuna örnektir

    # Preemptive Kernel
        bir process kernel modda çalışırken sonsuz öncelikte olabilir
        çalışyorsa sonsuza kadar çalışabilir
        **Race Contiditon Oluşabilir**
    # Non-Primitive Kernel
        bir process kernel modda çalışırken sonsuz öncelikte olamaz
        onun yerine başka daha önemli bir process çalıştırılabilir
        **Race Contiditon Oluşmaz**

    SMP 'symetric multiprocessing' de preemptive sistemler kurgulanması daha zordur
    **preemptive sistemler** daha hızlı cevap verir bu nedenle **gerçek zamanlı sistemlerde kullanılır**

    # Peterson Çözümü
        yazılım bazlı kritik bölüm problemi çözümüdür

        2 değişken eklenir flag ve turn

        # boolean flag[2] 'bayrak' -> true ise kritik sectiona girme isteği
        # int turn 'sıra'   -> sıralamasını belirliyor

        flag true ve turn geldiyse processin kritik sectionu çalışır ve flag false olur

    # senkronizasyon donanımı
        donanım tabanlı çözümler maliyetlidir

        Locking Yaklaşımı

        tek işlemcili sistemlerde interruptların paylaşılmış veriye erişimi engellerise sorun basitçe çözülmüş olur

        komut sırası yada önceliklendirme olmazsa sorun çözülmüş olur

        nonpreemtive kerneller kullanır

        Çok işlemcili sistemlerde uygun değildir -> interruptların açılıp kapanması için mesaj göndermek zaman alır, performans düşer

        // atomik -> peşi sıra çalışması gereken 2 metod, sırası değiştirlemez
        // context switch işlemide atomik olarak çalışır
        
        bounded waiting sağlanmaz, yazılımla bu eklenebilir

#### Mutex Kilitlenmeleri
    Yazılım tabanlı
    
    kritk bölüme girecekse acquire() funcion çalıştırır
        available = false
    kritk bölüme çıkacaksa release() funcion çalıştırır
        available = true

    boolean available değeri vardır erişilebilirliği değiştirir

#### Semaforlar
    bir int değeri üzerinden ilerlenir

    çalışılacaksa semafor değeri azaltılır 
    geri verilincede semafor değeri arttırılır

    # Sayma Semaforları
        sistemde ne kadar kaynak varsa onun sayısına eşittir
            10 yazıcı varsa int 10 dan başlar
        kaynağı kullanmak isteyen process semafor üzerinde wait işlemi gerçekleştirir
        bıraktığında signal çalışır değer 1 artar
    # binary semafor
        0 kullanılıyor
        1 kullanılmıyor

        mutex lock gibi davranır

    her semafor PCV pointırına sahiptir

    ```c
        wait(S){
            while(S >= 0) ; // busy
            S--;
        }
        signal(S){ S++; }
    ```
    # deadlock
    P0 -> wait(S) wait(Q) signal(S) signal(Q)
    P1 -> wait(Q) wait(S) signal(Q) signal(S)
                  ^ kilitlenme
#### İzleyiciler 'Monitors'
    semaforlar kullanıldığındada hatalar oluşabilir

    programcıdan kaynaklı sorunları engeller

    bir struct class oluşturularak mutex ve semafor gibi işlemler fonksiyon olarak gerçekleştirir
    monitor kendi verilerine erişebilir, fonksiyonlar kend içinde sıralıdır

    ```cs
    contidion x,y; // bunlar cooperating processler koşul olduğu için
    y.signal()
    x.wait()
    ```
    