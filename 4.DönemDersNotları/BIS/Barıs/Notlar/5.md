
### process scheduling
    **os temel amacı cpu kullanımını maksimuma çıkaracak şekilde processleri çalıştırmaktır**
    bir processin çalışması için process scheduler seçer

    # scheduling queues %%SORU%% %%TODO: fotoğraf%%
        bir process sisteme girdiğinde tüm işlerin bulunduğu iş kuyruğuna 'job queue' alınır
        processler hafızaya gelirse ready queueya alınır
        ready queue PCB lerin ilk ve son elemanlarını işaret eder
        bir process başka processi çalıştırırsa onun bitmesini bekler
        I/O isteğinde bulunursa I/O kuyruğuna girer
        zaman penceresi belirliyse tekrar ready kuyruğuna gelir süre bitince


    # Scheduler
        bir process farklı kuyruklara alınabilir
        kuyruktaki processleri scheduler seçer
        genellikle batch sistemlerde çok sayıda process çalıştırılmak üzere sisteme gönderilir
    // batch toplu bir paket dosya birden çok işlem olarak düşünülebilir
        %%SORU%%
        # Long-term Scheduler 'Job Scheduler'
            hangi process cpu ya geçecekse onu belirler
            dakike seviyesindeki aralıklarda çalışır
        # Short-term Scheduler 
            hazır - ready - cpu kuyruğundan seçerek çalıştırmaya gönderir
            kısa aralıklarla çalışır <100ms ve sıklıkla çalışır

        Windows ve Unix sistemler long-term scheduler kullanmazlar short term kullanırlar

    // processler i/o bound ve cpu bound olarak ayrılabilir
    // bunlar arasındaki denge kurulması gerekir
        # I/O Bound proces
            tüm processler böyle olursa ready queue boş kalır
        # CPU Bound process
            tüm processler böyle olursa I/O Queue boş kalır         

        # Swapping : hafıza gereksiniminin değişmesi gibi bazı durumlarda, process’ler hafızadan atılır ve daha sonra tekrar hafızaya alınır

    %%SORU:OVERHEAD%%
    //Overhead: boşa çalışma context switch sırasında
        # Context Switch
            cpunun mevcut context 'konfigürasyon' saklanır
            contextler PCB içinde saklanır 
            geri dönndüğünde bu contextten devam eder

### Process creation
-   dinamik olarak oluşturulurlar ve silinirler
-   çağıran process parent çağrılan process child dır

-   bir parent process yeni bir child process oluşturduğunda yeni child process cpu time hafıza dosyalar ve io cihazları gibi kaynaklara ihtiyaç duyar
-   processler child processlerden bağımsızda beklemesini bekleyerekde çalışabilir
-   mevcut processin iş yükünü azaltmak için fork, child processler kullanılabilir

### Process Termination
-   sonlanan process parent process e bir değer döndürmesini sağlar
-   child process ona tahsisis edilmiş kaynaklardan fazlasını istediğinde parent process onu sonlandırabilir
-   parent process sonlandırıldığında childlarında sonlandırılması istenebilir
-   windowsta TerminateProcess()
-   exit() doğrudan return int dolaylı sonlandırma yapar
-   **zombie process** sonlandırılmış fakat hala process tablosunda yer kaplayan bir processtir

### Processler arası iletişim
    processler independent yada cooperating process olarak çalışırlar
    **independent processler** diğer pprocessleri etklemez ve onlardan etkilenmes
    **cooperating processler** diğer processlerden etkilenirler yada diğerlerini etkilerler
        Information sharing : paylaşılmış dosyalar üzerinde işlem yapmak gerekebilir
        Computation speedup : birden fazla corea sahip işlemcili bilgisayarlarda görevlerin parçalar halinde eş zamanlı çalışmasını sağlar
        Modularity :   Sistem parçalar threadler halinde oluşturulabilir ve bu parçalar arasında işlem yapılabilir
        Convinience : bir kullanıcı farklı işleri aynı anda gerçekleştirebilir
        
        %%TODO: foto ekle%%
        # Shared Memory
            shared memory ve message passing ile veri aktarımı yaparlar
            shared memory daha hızlı bir yöntemdir
            herkez erişebilir güvenlik açısından sorun oluşabilir
            shared memory bi struct kullanır
            in ilk boş yeri out son dolu yeri gösterir
            in(), out()
        # Message Passing
            message queue için kernel moda geçmelidir bu vakit alır

            dağıtık ortamlardaki processlerin iletişiminde faydalıdır (chat programı)
            send(), receive()
            send(P, message), receive(Q, message)

### istemci sunucu sistemlerinde iletişim
    # Soketler
        soket ip adresi ve port ile tanımlanır
        belli portlar dinlenir
        bir ağ üzerinde iletişim soketler ile sağlanır
        HTTP 80 FTP 21
        bir host üzerindeki soketler tekil olmalıdır
        tüm processler için işletim sisteminin atadığı port numaralı farklı olmalıdır
        
        soketler arasında iki tür bağlantı yapılabilir
        connection-oriented reliable
        connectionless unreliable

        TCP reliable güvenli yavaş UDP unreliable güvensiz hızlı

        Javada TCP Socket sınıfı kullanılır UDP DatagramSocket sınıfı kullanılır

    %%TODO: Socketler Örnek%%
