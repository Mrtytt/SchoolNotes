### Alternatif yaklaşımlar
#### Transactional memory

atomik hale getirilerek fonksiyon sayısı azaltılır

```c
    void update()
    {
        atomic {
            //...
        }
    }
```
#### OpenMP

```c
    void update()
    {
        #pragma cmp critical
        {
            //...
        }
    }
```

%%SORU%%
## CPU Scheduling
* her zaman aralığında bir procesin çalışması amaçlanır
* özellikle multi-programming çalışan işletim sistemlerinde temel olarak yapılması gerekir

- Turnaround Time

* işletim sistemi processler için ne kadar uzun süreceğini tahmin eder
    - tahminler hem mevcuda göre, hem geçmişteki durumlara göre yapar

### CPU Burst Cycle & I/O Burst Cycle
* CPU Burst Cycle cpu kullandığı süre
* I/O Burst Cycle io beklenmesi
* CPU + I/O cycle lar process tamamlama süresini verir
* processler cpu burst cycle ile başlar

- cpu burst süresi process ten procese ve bilgisayardan bilgisayara değişir
* cpu burst süresi sıklıkla ve kısa olmalıdır

### CPU Scheduler
* CPU bekleme durumuna geçtiğinde, os ready queue den bir process seçmek zorundadır
- bu seçme short-term scheduler, cpu scheduler tarafından yapılır

* Ready Queue fifo, priority queue, sırarsız bağlı liste , ağaç şeklinde oluşturulabilir
* kuyruk içinde PCB ler tutulur

* 4 Durumda gerçekleşir
    - process çalışma durumundan bekleme durumuna geçince (i/o bekleme)
    - process çalışma durumundan hazır durumuna geçince (interrupt)
    - process bekleme durumundan hazır durumuna geçince (i/o tamamlanması)
    - process sonlandığında

* 1, 4 nonpreemptive veya cooperative scheduling
* 2, 3 preemptive scheduling
%%SORU:preemptive%%

preemptive scheduling de veri paylaşımı varsa race condition oluşur

### Dispatcher 'sevk edici'
* seçme işlemi yapıldıktan sonra seçilen process cpu ya dispatcher tarafından "sevk edilir"

* Neler yapar
    - context switch yapar
    - user moda geçiş
    - programı yeniden başlatmak için kullanıcı programında uygun konumu atlama

- dispaycher hızlı şekilde geçiş yapmalıdır
- processler arası geçiş süsresine dispatch latency denir

### Scheduling 'Planlama' Kriterleri

* CPU utilization
* Throughput        : Her zaman aralığında tammalanan process sayısıdır yani "verimlilik"
* Turn around time  : bir programın process haline gelmesi, cpu da çalışması, io beklemesi yani bir processin tüm hayatı
* Waiting time      : bir procesi hazır kuyruğunda beklediği süre
* Response time     : bir processe gönderilen isteğe cevap dönünceye kadar geçen süredir

* Amaç
    - CPU utilization ve throughputu maximize etmek
    - turn around time, waiting time, response time ı minimuma

### Scheduling Algoritmaları

* First-Come, First-Served Scheduling
* Shortest-Job-First Scheduling
* Priortiy Scheduling
* Round-Robing Scheduling               : Gerçek zamanlı sistemlerde
* Multilevel Queue Scheduling
* Multilevel Feedback Queue Scheduling

#### First-Come, First-Served Scheduling
* fifo çalışır
* en basit halidir
* ortalama bekleme süresi genellikle yüksektir
* bekleme süresi processlerin kuyruğa geliş şekline göre değişir

- processlerin çalışma süreleri çok farklıysa ortalama bekleme süreleri çok değişken olur

- i/o kuyruğu ve cpu kuyruğu uzun süre boş kalabilir

* convoy effect uzun bir procesin arkasında küçük processlerin beklemesi

* bu algoritma time-sharing sistemler için uygun değildir

#### Shortest-Job-First Scheduling
* en kısa olan cpu ya iletilir
- short termde sonraki çalışma süresi tahmin edilmeye çalışılır

* FCFS ye göre genellikle daha kısa ortalama bekleme süresi ve trunaround time a sahiptir

* en büyük zorluk sonraki çalışma süresini tahmin etmektir

* SJF genelde long-term scheduling için kullanılır

- T_n+1 = a*t_n + (1-a)T_n

- hem nonpreemptive hemde preemptive olabilir

#### Priortiy Scheduling
* SJF algoritmasının özel durumudur

* en yüksek öncelikli process cpu ya iletilir
* genelde en kısa burst time a daha yüksek öncelik tanınır
    - ki ortalama turnaround time ve bekleme süresi az olsun 
* öncelik değerleri eşitolanlar FCFS sırasıyla sıralanır

* priority verilmemişse burst time a bakılıp karar verilir

* Önceliklendirme kriterleri
    - zaman Sınırlı
    - hafıza gereksinimi
    - açılan dosya sayısı
    - I/O burst ve CPU burst oranına göre
    - processin önemi

* bu kriterlerden bir veya birkaçtanesi olabilir
* genelde en kısa burst time a daha yüksek öncelik tanınır

* hem preemptive hemde nonpreemptive çalışabilir
* eğer çalışma kuyruğuna daha öncelikli bir process gelirse
    - preemptive de mevcut kesilir
    - nonpreemptive de mevctun bitmesi gerekir

* indefinite blocking, starvation yaşanabilir
* hazır kuyruğunda processlerin hep arkasa kalma durumunu çözmek için kuyrukta beklerken öncelik seviyesi arttırılır
    - 10 sn bekleyince öncelik 1 arttırılabilir

#### Round-Robing Scheduling
* zaman paylaşımlı sistemlerde kullanılır

* herkez cpu yu time slice kadar kullanabilir
* time slice az seçilirse çok fazla context switch olması, çok seçilirse bekleme süresi artabilir
- daha kısada sonlanan proccssler cpu yu serbest bırakır

* ortalama bekleme süresi genellikle uzundur

- time slice == quantum

* en fazla bekleme süresi (n-1) * q olur

* çok context switch olduğundan pek iyi değildir, cpu time %10 u

#### Multilevel Queue Scheduling
* birden fazl hazır kuyruğu olması durumu
* hazır kuyrukları seviyelendirilir
    - örneğin foreground 'interaktif' ve background 'batch' olarak 2 gruba ayrılabilir
    - fore ground da response-time kısa olması gereklidir bundan daha öncelik verilebilir
    - her kuyruk kendi scheduling algoritmasını kullanabilir

#### Multilevel Feedback Queue Scheduling
* katmanlar arasında geçişlerin olabildiği durum
* i/o bound ve interaktif processler önceliklidir
* düşük öncelikli kuyrukta uzun süre bekleyen processler daha yüksek öncelikli kuyruğa taşınır ve indefinite loop sorunu çözülür