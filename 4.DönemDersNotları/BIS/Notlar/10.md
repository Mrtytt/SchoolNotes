### Alternatif Yaklaşımlar
#### Transactional Memory

- Atomik hale getirerek fonksiyon sayısını azaltırılır

```c
    void update()
    {
        atomic{
            //...
        }
    }
```

#### OpenMP
```c
    void update()
    {
        #pragma cmp critical
        {
            //...
        }
    }
```
##### Turn Around Time
- Bir process'in baştan sona çalışma süresidir.
- Waiting Time + CPU Burst Time denebilir.

## CPU Scheduling
- Her zamana aralığında bir process'in çalışması amaçlanır.
- Özellikle multi-programming çalışan işletim sistemlerinde temel olarak yapılması gerekir.

- İşletim sistemi processler için ne kadar uzun süreceğini tahmin eder.
    - Tahminler hem mevcuda göre hem geçmişteki durumlara göre yapar.

### CPU Burst Cycle & I/O Burst Cycle
- CPU Burst Cycle cpu kullandığı süredir.
- I/O Burst Cycle io beklenme süresidir.
- CPU + I/O cycle'lar process tamamlanma süresini belirler.
- Processler CPU Burst Cycle ile başlar, I/O ile devam eder.

- CPU Burst süresi process'ten process'e ve bilgisayardan bilgisayara fark eder.
- CPU Burst süresi sıklıkla ve kısa olmalıdır. (Context Switch)

### CPU Scheduler
- CPU bekleme durumuna geçtiğinde, işletim sistemi ready queue'dan bir process seçmek zorundadır.
- Bu seçme short-term scheduler, cpu scheduler tarafından yapılır.

- Ready Queue fifo, Priority Queue, Sırasız Bağlı Liste, ağaç şeklinde çalışabilir.
- Kuyruk içinde PCB'ler tutulur.

* 4 Durumda gerçekleşir.
    - Çalışma durumundan bekleme durumuna geçince (i/o bekleme)
    - Çalışma durumundan hazır durumuna geçince (interrupt)
    - Bekleme durumundan hazır durumuna geçince (i/o tamamlanması)
    - Sonlandığında

    - 1, 4 nonpreemptive veya coopertive scheduling
    - 2, 3 preemtive scheduling 

- Preemptive scheduling de veri paylaşımı var ise race condition oluşur.

### Dispatcher
- Seçme işlemi yapıldıktan sonra seçilen process cpu'ya dispatcher tarafından "sevk edilir".
* Neler yapar?
    - Context switch yapar.
    - User mode geçiş.
    - Programı yeniden başlatmak için kullanıcı programında uygun konumu atlama. 

- Dispather hızlı şekilde geçiş yapmalıdır.
- Processler arası geçiş süresine dispatch latency denir.

### Scheduling 'Planlama' Kriterleri 
- CPU Utilization       : CPU kullanım orasınıdır genelde %40-%90 arasındadır.
- Throughput            : Her zaman aralığında tamamlanan process sayısıdır yani verimlilik.
- Turn Around Time      : Bir programın process haline gelmesi, cpu da çalışması, i/o beklemesi yani process'in 
                        tüm hayatıdır.
- Waiting Time          : Bir process'in hazır kuyruğunda beklediği süre.
- Response Time         : Bir process'e gönderilen istğe cevap dönünceye kadar geçen süredir.

* Amaç
    - CPU utilization ve throughputu maximize etmek.
    - Turn Around Time, Waiting Time, Response Time'ı minimize etmek.

### Scheduling Algoritmaları
- First-Come, First-Served Scheduling
- Shortest-Job-First Scheduling
- Priority Scheduling
- Round-Robing Scheduling               : Gerçek zamanlı sistemlerde
- Multilevel Queue Scheduling
- Multilevel Feedback Queue Scheduling

#### First-Come, First-Served Scheduling
- Fifo çalışır.
- En basit halidir.
- Ortalama bekleme süresi genellikle yüksektir.
- Bekleme süresi processlerin kuyruğa geliş şekline göre değişir.

- Processlerin çalışma süresi çok farklıysa ortalama bekleme süreleri çok değişken olur.

- i/o kuyruğu ve cpu kuyruğu uzun süre boş kalabilir.

- Convoy Effect : Uzun bir processin arkasında küçük processlerin beklemesi

- Bu algoritma time-sharing sistemler için uygun değildir.

#### Shortest-Job-First Scheduling
- En kısa olan CPU'ya iletilir.
- FCFS ye göre genellikle daha kısa ortalama bekleme süresi ve turn around time'a sahiptir.

- En büyük zorluk sonraki çalışma süresini tahmin etmek zordur. Yani en kısa burst time olanı bulabilmektir.

- SJF algoritması genellikle long-term scheduling için kullanılır.

- Short-term scheduling seviyesinde kullanılmaz.

- T_n+1 = a*t_n + (1-a)T_n

- Hem nonpreemptive hem de preemptive olabilir.

- Preemptive SJF, shortest-time-remaining-first scheduling de denir.

#### Priority Scheduling
- SJF algoritmasının özel durumudur.

- En yüksek öncelikli process cpu'ya iletilir.

- Genelde en kısa burst time'a daha yüksek öncelik tanınır.
    - Ki ortalama turnaround time ve bekleme süresi az olur.

- Öncelik değerleri eşit olmaklar FCFS sırasıyla sıralanır.

- Priority verilmemişse burst time'a bakılıp karar verilir.

* Önceliklendirme Kriterleri
    - Zaman Sınırı
    - Hafıza gereksinimi
    - Açılan dosya sayısı
    - I/O burst ve CPU burst oranına göre
    - Processin önemi

- Bu kriterlerden bir veya birkaç tanesi olabilir.
- Genelde en kısa burst time'a daha yüksek öncelik tanınır.

- Hem preemtive hem de nonpreemtive çalışabilir.
- Eğer çalışma kuyruğuna daha öncelikli bir process gelirse
    - Preemptive de mevcut kesilir.
    - Nonpreemptive de mevcutun bitmesi gerekir.

- Indefinite blocking, starvation yaşanabilir.
- Hazır Kuyruğunda processlerin hep arkada kalma durumunu çözmek için kuyrukta beklerken öncelik seviyesi arttırılır.
    - Örnek : 10 sn beklerse 1 arttırılabilir.

#### Round-Robing Scheduling
- Zaman paylaşımlı sistemlerde kullanılır.

- CPU kullanım süresi belirler.Mesela herkes 5 ms kullanacak.

- Öncelik yok FCFS şeklinde ilerler.

- Çok büyük zaman seçilirse, process bitince bir sonrakine geçer.

- Çok kısa seçilirse sürekli context-switch olur. Bu da tavsiye edilmez.

- Time slice -> Süre, Quantum

- En fazla bekleme süresi (n-1) * q olur.

#### Multilevel Queue Scheduling
- Birden fazla hazır kuyruğu olması durumu.
- Hazır kuyrukları seviyelendirilebilir.
    - Örneğin foreground 'interaktif' ve background 'batch' olarak 2 gruba ayrılabilir.
    - Foreground da response-time kısa olması gereklidir. Bundan daha öncelik verilebilir.
    - Her kuyruk kendi scheduling algoritmasını kullanabilir. 

#### Multilevel Feedback Queue Scheduling
- Katmanlar arsında geçişlerin olabildiği durumdur. Yani kuyruklar arasında processler atlayabilir.
- i/o bound ve interaktif processler önceliklidir.
- Düşün öncelikli kuyrukta uzun süre bekleyen processler daha yüksek öncelikli kuyruğa taşınır ve 
indefinite loop sorunu çözülür. 