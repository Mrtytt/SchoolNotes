## System Utilities 'Sistem Programların'
    - Hardware - os - system utilities - application program
    - Kernel'ın dışında olan ama sistemin çalışması için gerekn programlar.

    - File Management
        - Dosyalar, dizinler ve işlemleri.
    - Status Information
        - Tarih, saat, hafıza, disk, boş alan, kullanıcı sayısı.
        - Log, debug, perfomans bilgileri istenebilir.
        - Bazı sistemler registry yapısınına sahiptir.
    - File Modification
        - Dosya içeriği görüntüleme, değiştirme
    - Programming-Language Support
        - Genelde c, cpp desteklerler.
    - Program Loading / Execution
        - Bir program derledikten sonra hafıza yüklenip çalıştırılmak için kullanılır.
    - Communications
        - Processler, sistem programları, kullanıcılar, bilgisayarlar, kernel içinde bağlantı kurulmasını sağlar.
    - Background Services
        - service, subsystem veya deamon olarak adlandırılır.
        - Bazıları çalışır bazıları tetiklenmeyi bekler.
        - Bazıları sistem boot edildikten sonra sonlandırılır basıları çalışmaya devam eder.
        - ex: Görev yöneticisi

## İşletim sistemleri tasarımı ve gerçekleştirilmesi

### Tasarım Hedefleri
    - Kullanıcı dostu, basit, kolay, hızlı
    - Gereksinimlerin belirlenmesi
### Mekanizmalar ve Kurallar
    - Kurallar 'policy' ne yapacağını belirler.
    - Mekanizmalar 'mechanisms' nasıl yapacağını belirler.
    - İkisi de güncellebilir, kurallar resource allocation için önemlidir.
### Implementation
    - İlk işletim sistemi assembly
    - Günümüz işletim sistemleri c ile
    - Kernel kısmı assembly  ile daha yüksek işlemler c/cpp ile yazılır.
    - Bir işletim sisteminin yüksek seviyeli dillerle yazılması farklı mikro işlemcilerde çalışabilmesini kolaylaştırır.
    - MS-DOS 8088 assembly ile yazılmış intelde çalışır.
    - Yüksek seviyeli dillerde yazılan işletim sistemleri daha hızlıdır.
    - Linux c ile yazılmıştır vs intel x86, oracle, ibm powerpc de çalışabilir.

## Kernel 'Çekirdek'
    - İşletim sisteminin donanıma en yakın kısmıdır.
### İşletim sistemi yapısı, mimarileri
    # Monolitik (basit) yapı
        - Elinde bir kernel var ne var ne yoksa içinde.
        - Tüm programlar kernel'a gömülmüş.
        - Sistemde oluşabilecek herhangi bir hata sistemin çökmesine sebep olabilir.
        - MS-DOS ve ilk UNIX örnek veribilir.
            - Process önceliklendirme yoktur.
            - Bu özelliği zararlı uygulamaların sistemi kolayca çökertmesini sağlar.
        - UNIX ilk geliştirildiğinde sistem ve kullanıcı program olarak ayırmış.
        - Yüksek memory kullanımı ve karmaşık kernel yapısı.
    # Katmanlar 'Shell' yapı
        - İşletim sistemlerinin gelişmesiyle ihtiyaç duyulan servislerin kernela dahil edilmek yerine katman katman dahil edilmesi.
        - En alt katman hardware en üst katman gui
        - Katman sayısı sınırlı değildir fakat sayı arttıkça karmaşıklık artar.
        - Katmanlarda yapılan bir güncelleme hepsinin tekrar compile'lanmasını gerektirir.
        - Her katman ayrı ayrı debug edilebilir.
        - Her katman altındaki katamnın özelliklerini kullanabilir ama bu sistemi yavaşlatır.
        - Katman sayısını az şekilde olması gerektirir.
    # Mikro Kernel
        - Sistemin açılıp çalıştırılması için gereken sistemleri içeriyor.
        - Bu yaklaşımda diğer kernaldaki sistemler sistem programı haline geliştirilmiş
        - UNIX geliştikçe kernel büyümüş ve yönetimi daha zor hale gelmiş.
        - '80 carnegie mellon üni Mach adında mikro kernel yapısı kullanan bir işletim sistemi geliştirilmiştir.
        - interprocess communication, memory managament, cpu scheduling
        - Process arası iletişim mesaj gönderimi ile yapılmıştır.
        - Çoğu servis kullanıcı olarak çalıştığından daha güvenlidir.
        - Mac OS X kernel'ı kısmen mikro kernel'a sahiptir.
        - Microsoft Net 4.0
    # Modüler
        - Kernel boot sırasında veya sistemin çalışması devam ederken yüklenen bileşenlere, modüllere sahiptir.
        - Modern işletim sistemlerinde popülerdir.
        - CPU ve hafıza yönetimi kernal'dadır diğerleri modül olarak yüklenebilir.
        - Bir modül kendisine yüklendikten sonra başka modüller çağrılabilir veya iletişime geçebilir.
        - Linux cihaz sürücüleri ve dosya sistemleri için kernel modullerini kullanır.
    # Hybrid
        - Günümüz işletim sistemleri tek bir yapıda değildir.
        - Farklı yapıların + yönlerini alırlar.
        - Linux ve solaris monolitik yapıdadır ama kernel ksımına yeni fonksiyonlar dinamik olarak eklenebilir.
        - Windows monolitik yapıdadır ama bazı temel işlevleri mikro kernelda yapar.
        - Bu tip yapılarda çekirdek zayıflatılır ve gelişmiş görevler için dinamik modüllerin eklenmesine izin verilir.
        - MAC OS X hibrit yapıya sahip
            - GUI -> Aqua
            - Kernel -> Mach, BSD
            - I/O -> Kernel Extensions
            - Cocoa objective C diline api sağlar.
            - Mach: Hafıza yönetimi, thread yönetimi, çağrı başlatma, processler arası iletişimi sağlar.
            - BSD : Command-line, ağ ve dosya sistemleri
        - IOS
            - MAC OS X  üzerine yapılandırılmış
            - Cocoa Touch : Objective c için api sağlar.
            - Media services: Grafik ve video.
            - Core services: cloud computing, db computing.
            - Core OS en alt katmandır.
        - Android
            - Hibrid yapı
            - Açık kaynak kodludur.
            - Zengin framework.
            ...
            - Libraries- Android Runtime
            - Linux Kernel
            - Kernel power managament, cihaz sürücüleri, process yönetimi, hafıza yönetimi.
            - Android Runtime -> Java için kütüphaneleri sağlar.
            - Dalvek Virtual MAchine - Java uygulamalarını çalıştırır.
            - Kütüphaneler...
    # ExoKernel 'dış çekirdek'
        - İşletim sistemlerinin temel fonsiyonlarından biri olan donanıma erişim
        yordamını diğer uygulamalarında erişimine açar. 
        - Bellek ve process yönetimi dışında tek yaptığı şey donanım arayüzlerinin
        çoklayarak uygulamalara aktarır 'multiplexing'
        - Donanım bazlı bir işlem yapıyorsak exokernel kullanılabilir. Programlaması zordur,
        bu yüzden gerçek hayatta tercih edilmez.

### İşletim Sisteminde Debugging
    - Performans Tuning olarakta adlandırılır.
    - Hata Analizi 
        - Bir process hata verdiğinde os bunu log dosyasına yazar
        Aynı zamanda memorynin anlık durumunda 'memmory dump' kaydeder.
        Kernelde çıkan hata **crash** olarak adlandırılır. Debug kod yazmaktan daha zordur.
    - Performance Tuning 
        - Sistemin performansını arttırmak için yapılan işlemlerdir. Sistemin 
        tıkanıklıklarının anlaşılması için kullanılır.
    - Task manager örnek verilebilir.

### İşletim Sistemlerinin Kurulması

#### System Booting
    - Kernelin yüklenerek başlatılmasına **booting** denir.
    - Bootstrap rom üzerindedir ve kerneli yükler.
    - Boot kısmına sahip olan disk, boot disk veya system disk olarak adlandırılır.
    - Mobl cihazlarda eprom yaygındır.

## Process Kavramı
    - Süreç, işlem , process anlamında kullanılmıştır.
    - Modern işletim sistemlerinde process işin bir parçasıdır. CPU aralarında geçiş yaparak
    tüm processlerin eş zamanlı çalıştırılabilir.
    - Bir sistem tek kullanıcılı bile olsa birden fazla uygulamayı birlikte çalıştırılabilir.
    - İşletim sistemi multitasking desteklemese de eğer context switch yapabiliyorsa os kendi
    fonksiyonlarını çağırarak bunun benzeri yapabilir.
    - Bir programın os kontrolü altında çalıştırılan  canlı-aktif halidir.
    - Bir programı çalıştırdırılması için os tarafından bir process oluşturulmalı ve process
    ile ilgili program ilişkilendirilmelidir.
    - Programın çalışması için gereken kod parçacıkları process aktarılır.
    - Processler programlardan bağımsız varlıklardır. Bir x processi bir gün chrome yarın excel çalıştırılabilir.
    - Daha hızlı çalışabilmek için adına işletim sistemleri boşta iken hazırda processler bekletir. 'Yedekli çalışıyor'.
    - Bir process ancak 1 program ile ilişkilendirilmelidir. ama bu ilişki çalışma sırasında değiştirilebilir
    - Process ile program arasında 1:1 ; program ile process arasında 1:N ilişki vardır.
    - Bir process yürütmekte olduğu işi, program counter değerini, cpu registerlerinin değerlerini içermektedir
    - Stack - ... - Heap - Data(Global Değişkenler) - Text
    - Her bir process'in process kontrol bloğu vardır -> 'processin kimlik kart'
    

### Process Oluşturma Adımları 
    - Bir process tamamen durdurulana kadar bekletilerek yeniden kullanılabilir.

### Process State
    - New        : Process oluşturulmaktadır.
    - Running    : Komutlar çağırılmaktadır.
    - Waiting    : Process bir olayın gerçekleşmesini beklemektedir.
    - Ready      : CPU ya geçmek için bekliyor.
    - Terminated : Process çalışmasını sonlandırılır.

    - Bunların hepsinde queue veri yapısı kullanılır.
    - Waiting de queue'den bahsetmek doğru değildir.

### Process Control Block
    - Yapısı
        - Process State
        - Process Number : ID
        - Program counter : Bir sonraki çalışacak kodun yeri
        ---
        registers
        ---
        - Memory limits : Base adresin neresi limitin neresi olduğunu yazar.
        - List of open files
        ...
    - Cpu scheduling information : Önceliğini içerir.
    - Accounting indormation
    - i/o status
    - Bir process çalışmaya başladığında önce ilk yüklenene process kontrol bloğu 
    bilgileri yüklenir.

### Process Planlama 
    - OS temel amacı cpu kullanımını maksimuma çıkaracak şekilde processleri çalıştırmaktır.
    - Bir processin çalışması için process scheduler seçer.

    (R) Scheduling Queue MUTLAKA SORAR!!!
        - Bir process sisteme girdiğinde tüm işlerin bulunduğu iş kuyruğuna 'job queue' alınır.
        - Process hafızaya gelirse ready queue'ya alınır.
        - Ready queue PCB 'lerin ilk ve son elemanlarını işaret eder.
		- Bir process başka bir processi çalıştırırsa onun bitmesini bekler.
		- I/O isteğinde bulunursa I/O kuyruğuna girer.
		- Zaman penceresi belirliyse tekrar ready kuyruğuna gelir süresi bitince.

    (R) Scheduler
    	- Bir process farklı kyruklara alınabilir.
    	- Kuyruktaki processler scheduler seçer.
    	- Genellikle batch sistemlerde çok sayıda process çalıştırılmak üzere sisteme gönderilir.
    	- Batch toplu bir paket dosya birden çok işlem olarak düşünülebilir.
    	
    	**Soru**
    	# Long-Term Scheduler 'Job Scheduler'
    		- Hangi process CPU'ya geçecekse onu belirler
    		- Dakika seviyesinde aralıklarla çalışır.
    	# Short-Term Scheduler
    		- Hazır - ready - cpu kaynağından seçerek çalıştırılmaya gönderir.
    		- Kısa aralıklarla çalışır <100ms ve sıklıkla çalışır.

    	- Windows ve Unix sistemler long-term scheduler kullanmazlar short term kullanırlar.

    - Processler i/o bound ve cpu bound olarak ayrılabilir.
    - Bunlar arasındaki dengenin kurulması gerekir.
    	# I/O Bound Process
			- Tüm processler böyle olursa ready queue boş kalır.
		# CPU Bound Process
			- Tüm processler böyle olursa I/O queue boş kalır.
		# Swapping
		# OverHead
			**Soru**
			- Boşa çalışma anlamına gelir.
		# Context Switch
			- Cpunun mevcut context 'konfigürasyon' saklanır.
			- Geri döndüğünde bu contextten devam eder.

### Process Creation
	- Çağıran process parent çağrılan process child'dır
	- Bir Parent process yeni bir child process oluşturduğunda yeni child process cpu time 
	hafıza dosyalar ve io cihazları gibi kaynaklara ihtiyaç duyar.
	- Processler child processlerden bağımsızda beklemesini bekleyerek çalışabilir.
    - Mevcut process'in iş yükünü azaltmak için fork, child processler kullanılabilir.

### Process Termination
	- Sonlanan process parent process'e bir değer döndürmesini sağlar.
	- Bir parent process child process'lerin sonlanmasına neden olabilir.(Windows'ta TerminateProcess())
	- Child process kaynak sınırını aştığında parent process tarafından sonlandırılabilir.
	- Parent processler sonlandırıldığında child processlerin de sonlandırılması istenebilir.
	- Child process'in yaptığı işe gerek kalmayabilir.
	- exit() doğrudan, return int dolaylı sonlandırma yapılır.

### Processler Arası İletişim
	-  Processler independent ya da cooperating process olarak çalışırlar.
	- **Independent processler** diğer processleri etkilemez ve onlardan etkilenmez.
	- **Cooperating processler** diğer processleri etkiler ve onlardan etkilenirler.
		- Information sharing : Paylaşılmış dosyalar üzerinde işlem yapmak gerekebilir.
		- Computation speedup : Birden fazla core'a sahip işlemcili bilgisayarlarda görevlerin parçalar 
		halinde eş zamanlı çalışmasını sağlar.
		- Modularity : Sistem parçalar threadler halinde oluşturulabilir ve bu parçalar arasında
		işlem yapılabilir.
		- Convenience : Bir kullanıcı farklı işleri aynı anda gerçekleştirebilirler.

#### Shared Memory
	- Shared memory ve message passing ile veri aktarımı sağlanır.
	- Shared memory daha hızlı bir yöntemdir.
	- Herkes erişebilir güvenlik açısından sorun oluşturabilir.
	- Shared memory de struct yapısı kullanılılabilir.
	- In ile veri yükleyebilir, out ile son dolu yeri gösterir. 
	- in(), out()

#### Message Passing 		
	- Message queue için kernel moda geçmelidir. Bu da vakit alır.
	- Dağıtık ortamlardaki processlerin iletişiminde faydalıdır. (Chat programı).
	- İki fonksiyonu vardır. Send() ve Receive().
	- Send(P,message) -> P'ye mesaj gönderilir, Receive(Q,message) -> Q'dan mesaj alınır.

### İstemci-Sunucu Sistemlerde İletişim

#### Soketler
	- Soket IP adresi ve port'ları ile tanımlanır.
	- Belli portlar dinlenir.
	- Bir ağ üzerinde iletişim soketler ile sağlanır.
	- HTTP 80, FTP 21
	- Bir host üzerindeki soketler tekil olmalıdır.
	- Tüm processler için işletim sisteminin atadığı port numaralı farklı olmalıdır.

	- Soketler arasında iki tür bağlantı yapılabilir.
		- Connection-oriented reliable
		- Connectionless unreliable
	- TCP reliable güvenli ve yavaş, UDP unreliable güvensiz hızlı.
	- Javada TCP Socket sınıfı kullanılır UDP DatagramSocket sınıfını kullanır.
	**Soketler Örneği**

## Thread (İş Parçacığı-İplik)
	- Mevcutta çalışan bir process iş parçalarıdır.
	- Tüm processlerin threadleri bir çizelgede tutlur ve bunlar zaman paylaşımlı çalıştırılır.
	- Thread async ya da sync çalışabilir.
	- Bir thread çalışmasına bir süre ara verir ve diğer threadler çalışır. Biz bunu farkedemeyiz.
	- Threadler user ve kernel thread olarak ikiye ayrılır.
	- Thread mantığı compiler ve developera bırakılmıştır. Kodlanmazsa tek bir büyük thread olarak çalışır.

	(R)Stateler
		- New 				=	Yeni oluşmuş threadler yine processlerde olduğu gibi hız için hazır boşta bekletilir.
								Threadler yine processlere link edilir.
		- Ready / Runnable	=	Çalışmaya hazır, bazen çalışmıyor da olabilir.
		- Blocked / Waiting = 	Duraklatılabilir bir event bekleyebilir, interrupt yiyebilir.
		- Terminated		=	
		**SORU** 
			- Threadler bağımsız çalışabilir yine de bir process'e link kurması gerekir. Process sonlansa da 
			çalışmaya devam edebilir.
		
	- Program counter, register, stack'a sahiptir.
	- Threadler program kodunu data kısmını dosyalar gibi işletim sistemi kaynaklarını ortak kullanır.
	- Process ile thread arasında parent child ilişkisi var denilebilir.
	- Klasik processler tek bir thread'e sahiptir.
	- Eğer bir process birden fazla thread'e sahipse birden fazla görevi eş zamanlı yapabilir.
	- Günümüzde çalışan programlar bir çoğu multi-thread çalışır.
	- Process Google Chrome, her bir tab thread olarak örnek verilebilir.

	- İşletim sisteminin kernelları muti-thread yapıdadır. Aynı anda cihaz yönetimi,hafıza yönetimi
	veya interrupt işlemleri aynı anda yapılabilir.

	(R)Faydaları
		1. **Cevaplanabilirlik (Responsiveness)** : Biri kasaya bakar biri bulaşığı yıkar.
		2. **Kaynak Paylaşımı (Resource Sharing)** : Threadler kaynaklarını ana processteki data ya da 
		fileları paylaşabilir, aralarında shared memory ya da message passing yapabilirler.
		3. **Ekonomi (Economy)** : Bir process oluşturulurken hafıza ve kaynak tahsis edilmesi
		maliyet yüksek bir iştir; Process'in kaynaklarını paylaştıkları için context switch
		daha düşük maliyete yapılır. (Solaris sisteminde thread oluşturma 30 kat daha hızlı ve threadlerde
		context switch 5 kat daha hızlıdır.)
		4. **Ölçeklenebilirlik (Scalability)** : Çok işlemcili mimarilerde threadler farklı core'lar üzerinde
		eş zamanlı çalışabilir ancak tek thread yapısına sahip processler sadece bir işlemci üzerinde çalışabilir. 
    
## Multi-core Programlama
	- İşletim sistemi için her çekirdeği ayrı bir işlemci olarak görür.
	- Her core'a bir thread atanarak paralel işlemlerin yapılması sağlanır.
	- Paralelism birden fazla görevin eş zamanlı yapılmasıdır.
	- Eş zamanlılık (concurecy) birden fazla thread arasında kısa aralıklarla geçiş yapılmasıdır.

	- Core sayısının artması, core frekansının 2 katına çıkarılması, işlem yapma hızını artırır denenebilir
	fakat 2 katına çıkarır gibi yorum yapılamaz.

	- Sisteme verilen seri işlemlerin sayısı artarsa hız yavaşlar
	- Sisteme verilen paralel işlemlerin sayısı artarsa hız hızlanır.
	- Andal Kuralı
		**TODO add formula**
		- (1/S + (1-S)/N)
		- S = seri işlem yüzdesi, N core sayısı
		- Core sayısıyla paralel bir ilişki olmadığı için bu formül gerekmiştir.
	- İşletim sistemi tasarımcıları multicore sistemlerin performansını arttırmak için scheduling 
	algoritmalarını yazmalıdırlar.
	- Uygulama geliştiricilerinde mevcut programlarını değiştirmeleri multi-threaded tasarlanması gerekir.
	
	(R) Zorlukları
		1. **Identifying tasks** (Görev tanımlanması) : İşi kaç threade böleceğiz.
		2. **Balance** : İş yüklerinin eşit dağıtılması.
		3. **Data Splitting** : Verilerin nasıl bölüneceği.
		4. **Data Dependency** : Bir thread'in erişeceği verinin diğer görevlerle bağımlılıklarının incelenmesi
		gerekir aynı dosyada çalışmaörnek verilebilir.
		5. **Testing And Debugging** : Multi-threaded çalışan programların test ve debug işlemleri daha zordurlar. 

#### Paralel Çalıştırma Türleri
	(R) Data Paralelism
		- Aynı veri kümesine ait alt parçaların dağıtılmasıyla
	(R) Task Paralelism
		- Data ortak oladabilir olmayadabilir.
		- Aynı veri üzerinde artimetik ortalama aln ve geometrik ortalama alan 2 threadin olması örnek verilebilir.

#### İşlemler Arasında İletişim
	(R) Sinyal Mekanizması 
		- Bir veya birden fazla olayın gerçekleştiğini asenkron olarak haber vermesini sağlamak için gerçekleştirilmiştir.
		- İşlemlerin birbirine mesaj gönderebilmesi için aynı process'e bağlı olması gerekir ya da aynı sinyal
		grubunda olmalıdırlar.
		- İlgili işlemlerin sinyali algılaması için çalışma durumunda olması gerekir.
		- **Dispatcher**
	(R) Pipe (Boru)
